import os
import logging
import traceback
from datetime import datetime, timedelta
from flask import Flask, request, jsonify, session, flash, redirect, url_for, render_template
from flask_sqlalchemy import SQLAlchemy
from flask_apscheduler import APScheduler
import boto3
from botocore.exceptions import ClientError, NoCredentialsError, BotoCoreError
from werkzeug.security import generate_password_hash, check_password_hash
from flask_login import login_required, current_user
from croniter import croniter
import pytz
from collections import defaultdict

# Install croniter if not already installed: pip install croniter
try:
    from croniter import croniter
    CRONITER_AVAILABLE = True
except ImportError:
    CRONITER_AVAILABLE = False
    print("Warning: croniter not installed. Install with: pip install croniter")

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s %(levelname)s %(name)s %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()  # Also log to console
    ]
)

logger = logging.getLogger(__name__)

# Initialize Flask app
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'your-secret-key-here')
app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL', 'sqlite:///backup_manager.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False


# Initialize extensions
db = SQLAlchemy(app)
scheduler = APScheduler()

############################################################ Models ############################################################
class User(db.Model):
    __tablename__ = 'user'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(50), unique=True, nullable=False)
    password_hash = db.Column(db.String(120), nullable=False)
    email = db.Column(db.String(120))
    two_factor_enabled = db.Column(db.Boolean, default=False)
    two_factor_secret = db.Column(db.String(32), nullable=True)
    
    # ADD THESE NEW FIELDS:
    aws_access_key_id = db.Column(db.String(255), nullable=True)
    aws_secret_access_key = db.Column(db.String(255), nullable=True)
    region = db.Column(db.String(50), default='us-east-1')
    timezone = db.Column(db.String(50), default='UTC')
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    def set_password(self, password):
        self.password_hash = generate_password_hash(password)

    def check_password(self, password):
        return check_password_hash(self.password_hash, password)

class Instance(db.Model):
    __tablename__ = 'instances'
    id = db.Column(db.Integer, primary_key=True)
    instance_id = db.Column(db.String(100), unique=True, nullable=False)
    instance_name = db.Column(db.String(100))
    region = db.Column(db.String(50), nullable=False)
    access_key = db.Column(db.String(100), nullable=False)
    secret_key = db.Column(db.String(100), nullable=False)
    backup_frequency = db.Column(db.String(50), default="60")  # Default 60 minutes
    retention_days = db.Column(db.Integer, default=7)


class BackupSettings(db.Model):
    __tablename__ = 'backup_settings'
    id = db.Column(db.Integer, primary_key=True)
    retention_days = db.Column(db.Integer, default=7)
    backup_frequency = db.Column(db.String(64), default="60")  # Default 60 minutes
    instance_id = db.Column(db.String(64), nullable=False, default="global")
    created_at = db.Column(db.DateTime, default=datetime.utcnow)


class Backup(db.Model):
    __tablename__ = 'backups'
    id = db.Column(db.Integer, primary_key=True)
    retention_days = db.Column(db.Integer, default=7)
    instance_id = db.Column(db.String(64), nullable=False)
    instance_name = db.Column(db.String(128))
    ami_id = db.Column(db.String(100), nullable=False)
    ami_name = db.Column(db.String(128))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    status = db.Column(db.String(32), default='Pending')  # 'Pending', 'Success', 'Failed'
    region = db.Column(db.String(50))
    log_url = db.Column(db.String(256))


class Schedule(db.Model):
    __tablename__ = 'schedules'
    id = db.Column(db.Integer, primary_key=True)
    job_id = db.Column(db.String(100), unique=True, nullable=False)
    instance_id = db.Column(db.String(100), nullable=False)
    frequency = db.Column(db.String(50))
    next_run_time = db.Column(db.DateTime)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

############################################################ Routes ############################################################
@app.route('/')
def dashboard():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    user = User.query.filter_by(username=session['username']).first()
    if not user:
        session.clear()
        return redirect(url_for('login'))
    
    # Query all backups, most recent first
    backups = Backup.query.order_by(Backup.timestamp.desc()).all()
    last_backup = backups[0] if backups else None
    return render_template('dashboard.html', user=user, backups=backups, last_backup=last_backup)


@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        uname = request.form.get('username', '').strip()
        pwd = request.form.get('password', '')
        
        if not uname or not pwd:
            flash("Username and password are required", "danger")
            return render_template('login.html')
        
        user = User.query.filter_by(username=uname).first()
        if user and user.check_password(pwd):
            if user.two_factor_enabled and user.two_factor_secret:
                session['pending_2fa_user'] = user.username
                # If AJAX, respond with JSON to trigger 2FA popup
                if request.is_json or request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                    return jsonify({'require_2fa': True})
                # Fallback for non-AJAX
                return render_template('login.html', require_2fa=True)
            
            # Normal login
            session['username'] = user.username
            if request.is_json or request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'success': True, 'redirect': url_for('dashboard')})
            else:
                return redirect(url_for('dashboard'))
        else:
            if request.is_json or request.headers.get('X-Requested-With') == 'XMLHttpRequest':
                return jsonify({'success': False, 'error': 'Invalid credentials'})
            else:
                flash("Invalid credentials", "danger")
                return render_template('login.html')
    
    return render_template('login.html')


@app.route('/login_2fa', methods=['POST'])
def login_2fa():
    pending_user = session.get('pending_2fa_user')
    if not pending_user:
        return jsonify({'success': False, 'error': 'No 2FA session found. Please login again.'})
    
    user = User.query.filter_by(username=pending_user).first()
    if not user or not user.two_factor_enabled or not user.two_factor_secret:
        return jsonify({'success': False, 'error': '2FA not enabled for this user.'})
    
    code = request.form.get('code', '').strip()
    if not code:
        return jsonify({'success': False, 'error': '2FA code is required.'})
    
    totp = pyotp.TOTP(user.two_factor_secret)
    if totp.verify(code):
        session.pop('pending_2fa_user', None)
        session['username'] = user.username
        return jsonify({'success': True, 'redirect': url_for('dashboard')})
    else:
        return jsonify({'success': False, 'error': 'Invalid 2FA code. Please try again.'})


@app.route('/setup-2fa', methods=['GET', 'POST'])
def setup_2fa():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    user = User.query.filter_by(username=session['username']).first()
    if not user:
        session.clear()
        return redirect(url_for('login'))

    if not user.two_factor_secret:
        # Generate a new secret
        secret = pyotp.random_base32()
        user.two_factor_secret = secret
        db.session.commit()
    else:
        secret = user.two_factor_secret

    totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
        name=user.email or user.username,
        issuer_name="AWS Backup Dashboard"
    )

    # Generate QR code as base64
    img = qrcode.make(totp_uri)
    buf = io.BytesIO()
    img.save(buf, format='PNG')
    qr_b64 = base64.b64encode(buf.getvalue()).decode('utf-8')

    if request.method == 'POST':
        code = request.form.get('code', '').strip()
        if not code:
            flash("2FA code is required.", "danger")
            return render_template('setup_2fa.html', qr_b64=qr_b64, secret=secret)
        
        totp = pyotp.TOTP(secret)
        if totp.verify(code):
            user.two_factor_enabled = True
            db.session.commit()
            flash("2FA enabled successfully!", "success")
            return redirect(url_for('user_settings'))
        else:
            flash("Invalid code. Please try again.", "danger")

    return render_template('setup_2fa.html', qr_b64=qr_b64, secret=secret)


@app.route('/logout')
def logout():
    session.clear()
    return redirect(url_for('login'))

############################################################ User Management ############################################################

@app.route('/user-settings', methods=['GET'])
def user_settings():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    users = User.query.all()
    current_user = User.query.filter_by(username=session['username']).first()
    if not current_user:
        session.clear()
        return redirect(url_for('login'))
    
    return render_template('user_settings.html', users=users, current_user=current_user)


@app.route('/add-user', methods=['POST'])
def add_user():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    username = request.form.get('username', '').strip()
    email = request.form.get('email', '').strip()
    password = request.form.get('password', '')
    
    if not username or not password:
        flash("Username and password are required", "danger")
        return redirect(url_for('user_settings'))
    
    # Check if user already exists
    existing_user = User.query.filter_by(username=username).first()
    if existing_user:
        flash(f"User '{username}' already exists", "danger")
        return redirect(url_for('user_settings'))
    
    try:
        user = User(username=username, email=email)
        user.set_password(password)
        db.session.add(user)
        db.session.commit()
        flash("User added successfully", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error adding user: {str(e)}", "danger")
    
    return redirect(url_for('user_settings'))


@app.route('/delete-user', methods=['POST'])
def delete_user():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    uname = request.form.get('username', '').strip()
    if not uname:
        flash("Username is required", "danger")
        return redirect(url_for('user_settings'))
    
    # Prevent deleting yourself
    if uname == session['username']:
        flash("You cannot delete your own account", "danger")
        return redirect(url_for('user_settings'))
    
    user = User.query.filter_by(username=uname).first()
    if user:
        try:
            db.session.delete(user)
            db.session.commit()
            flash(f"User '{uname}' deleted", "info")
        except Exception as e:
            db.session.rollback()
            flash(f"Error deleting user: {str(e)}", "danger")
    else:
        flash(f"User '{uname}' not found", "warning")
    
    return redirect(url_for('user_settings'))


@app.route('/reset_password', methods=['POST'])
def reset_password():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    username = request.form.get('username', '').strip()
    new_password = request.form.get('new_password', '')
    
    if not username or not new_password:
        flash("Username and new password are required.", "danger")
        return redirect(url_for('user_settings'))

    user = User.query.filter_by(username=username).first()
    if not user:
        flash(f"User '{username}' not found.", "danger")
        return redirect(url_for('user_settings'))

    try:
        user.set_password(new_password)
        db.session.commit()
        flash(f"Password reset complete for {username}.", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error resetting password: {str(e)}", "danger")
    
    return redirect(url_for('user_settings'))


@app.route('/update-profile', methods=['POST'])
def update_profile():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    user = User.query.filter_by(username=session['username']).first()
    if not user:
        session.clear()
        return redirect(url_for('login'))

    new_email = request.form.get('email', '').strip()
    if new_email:
        user.email = new_email
        try:
            db.session.commit()
            flash("Profile updated successfully.", "success")
        except Exception as e:
            db.session.rollback()
            flash(f"Error updating profile: {str(e)}", "danger")
    else:
        flash("Email cannot be empty.", "danger")
    
    return redirect(url_for('user_settings'))


@app.route('/toggle-2fa', methods=['POST'])
def toggle_2fa():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    user = User.query.filter_by(username=session['username']).first()
    if not user:
        session.clear()
        return redirect(url_for('login'))

    enable_2fa = 'enable_2fa' in request.form
    user.two_factor_enabled = enable_2fa
    
    try:
        db.session.commit()
        flash("Two-factor authentication setting updated.", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error updating 2FA setting: {str(e)}", "danger")
    
    return redirect(url_for('user_settings'))


@app.route('/reinit-db', methods=['POST'])
def reinit_db():
    if 'username' not in session:
        return jsonify({'status': 'error', 'message': "You must be logged in."}), 403

    user = User.query.filter_by(username=session['username']).first()
    if not user or user.username != 'admin':
        return jsonify({'status': 'error', 'message': "Only admin can reinitialize the database."}), 403

    try:
        # Get password from request
        data = request.get_json() or {}
        password = data.get('password')
        if not password:
            password = secrets.token_urlsafe(16)

        username = "admin"
        email = "admin@example.com"

        # Drop all tables and recreate them
        db.drop_all()
        db.create_all()

        # Create default admin user
        admin_user = User(username=username, email=email)
        admin_user.set_password(password)
        db.session.add(admin_user)
        db.session.commit()

        return jsonify({
            'status': 'success',
            'username': username,
            'password': password,
            'email': email,
            'message': "Database reinitialized. Default admin user recreated."
        })
    except Exception as e:
        db.session.rollback()
        return jsonify({'status': 'error', 'message': f"Error reinitializing database: {str(e)}"}), 500

############################################################ AWS Instances ############################################################

@app.route('/aws-instances', methods=['GET'])
def manage_instances():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    instances = Instance.query.all()
    return render_template('aws_instances.html', instances=instances)


@app.route('/add-instance', methods=['GET', 'POST'])
def add_instance():
    if 'username' not in session:
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        instance_id = request.form.get('instance_id', '').strip()
        instance_name = request.form.get('instance_name', '').strip()
        access_key = request.form.get('access_key', '').strip()
        secret_key = request.form.get('secret_key', '').strip()
        backup_frequency = request.form.get('backup_frequency', '60')
        custom_backup_frequency = request.form.get('custom_backup_frequency', '').strip()
        retention_days = request.form.get('retention_days', 7)
        region = request.form.get('region', '').strip()
        
        # Validation
        if not all([instance_id, instance_name, access_key, secret_key, region]):
            flash("All fields are required.", "danger")
            return redirect(url_for('add_instance'))
        
        # Handle custom region
        if region == 'custom':
            region = request.form.get('custom_region', '').strip()
        if not region:
            flash("Region is required.", "danger")
            return redirect(url_for('add_instance'))
            
        # Handle custom backup frequency
        if backup_frequency == 'custom':
            backup_frequency = custom_backup_frequency
        if not backup_frequency:
            flash("Backup frequency is required.", "danger")
            return redirect(url_for('add_instance'))
        
        # Check if instance already exists
        existing_instance = Instance.query.filter_by(instance_id=instance_id).first()
        if existing_instance:
            flash(f"Instance '{instance_id}' already exists.", "danger")
            return redirect(url_for('add_instance'))
            
        # Validate AWS credentials and instance existence
        try:
            session_aws = boto3.Session(
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key,
                region_name=region
            )
            
            ec2 = session_aws.client('ec2')
            response = ec2.describe_instances(InstanceIds=[instance_id])
            
            # Verify instance exists and get actual name
            if 'Reservations' in response and response['Reservations']:
                instances = response['Reservations'][0]['Instances']
                if instances:
                    actual_name = None
                    for tag in instances[0].get('Tags', []):
                        if tag['Key'] == 'Name':
                            actual_name = tag['Value']
                            break
                    
                    if actual_name and actual_name != instance_name:
                        flash(f"Warning: AWS instance name is '{actual_name}', but you entered '{instance_name}'. Using AWS name.", "warning")
                        instance_name = actual_name
                
        except ClientError as e:
            error_code = e.response.get('Error', {}).get('Code', '')
            if error_code == 'InvalidInstanceID.NotFound':
                flash(f"Instance ID '{instance_id}' not found in AWS.", "danger")
            elif error_code in ['AuthFailure', 'UnauthorizedOperation']:
                flash("AWS authentication failed. Check your credentials.", "danger")
            else:
                flash(f"AWS error: {str(e)}", "danger")
            return redirect(url_for('add_instance'))
        except NoCredentialsError:
            flash("Invalid AWS credentials.", "danger")
            return redirect(url_for('add_instance'))
        except Exception as e:
            flash(f"Error validating AWS details: {str(e)}", "danger")
            return redirect(url_for('add_instance'))

        # Add instance to database
        try:
            inst = Instance(
                instance_id=instance_id,
                instance_name=instance_name,
                access_key=access_key,
                secret_key=secret_key,
                region=region,
                backup_frequency=backup_frequency,
                retention_days=int(retention_days)
            )
            db.session.add(inst)
            db.session.commit()
            
            # Schedule backup jobs
            schedule_all_instance_backups()
            
            flash('Instance added successfully!', 'success')
            return redirect(url_for('manage_instances'))
        except Exception as e:
            db.session.rollback()
            flash(f"Error adding instance: {str(e)}", "danger")
            return redirect(url_for('add_instance'))
    
    return render_template('add_instance.html')


@app.route('/delete-instance/<instance_id>', methods=['POST'])
def delete_instance(instance_id):
    if 'username' not in session:
        return redirect(url_for('login'))
    
    instance = Instance.query.filter_by(instance_id=instance_id).first()
    if instance:
        try:
            # Remove scheduled jobs
            job_id = f"backup_{instance_id}"
            try:
                scheduler.remove_job(job_id)
            except Exception:
                pass
            
            # Remove schedule record
            schedule = Schedule.query.filter_by(job_id=job_id).first()
            if schedule:
                db.session.delete(schedule)
            
            # Delete instance
            db.session.delete(instance)
            db.session.commit()
            flash('Instance deleted!', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f"Error deleting instance: {str(e)}", "danger")
    else:
        flash('Instance not found!', 'warning')
    
    return redirect(url_for('manage_instances'))


@app.route('/update-instance/<instance_id>', methods=['POST'])
def update_instance(instance_id):
    if 'username' not in session:
        return redirect(url_for('login'))
    
    inst = Instance.query.filter_by(instance_id=instance_id).first()
    if not inst:
        flash('Instance not found!', 'danger')
        return redirect(url_for('manage_instances'))
    
    try:
        inst.instance_name = request.form.get('instance_name', inst.instance_name)
        backup_frequency = request.form.get('backup_frequency', inst.backup_frequency)
        custom_backup_frequency = request.form.get('custom_backup_frequency', '').strip()
        retention_days = request.form.get('retention_days', inst.retention_days)

        # Handle custom backup frequency
        if backup_frequency == 'custom':
            backup_frequency = custom_backup_frequency
        
        inst.backup_frequency = backup_frequency
        inst.retention_days = int(retention_days)
        
        db.session.commit()
        
        # Reschedule backup jobs
        schedule_all_instance_backups()
        
        flash('Instance updated!', 'success')
    except Exception as e:
        db.session.rollback()
        flash(f"Error updating instance: {str(e)}", "danger")
    
    return redirect(url_for('manage_instances'))

@app.route('/aws-settings', methods=['GET', 'POST'])
def aws_settings():
    """Route to manage AWS credentials"""
    if 'user_id' not in session:
        return redirect(url_for('login'))
    
    user = User.query.get(session['user_id'])
    if not user:
        flash('User not found', 'error')
        return redirect(url_for('login'))
    
    if request.method == 'POST':
        # Update AWS credentials
        user.aws_access_key_id = request.form.get('aws_access_key_id')
        user.aws_secret_access_key = request.form.get('aws_secret_access_key')
        user.region = request.form.get('region', 'us-east-1')
        user.timezone = request.form.get('timezone', 'UTC')
        user.updated_at = datetime.utcnow()
        
        try:
            db.session.commit()
            flash('AWS settings updated successfully!', 'success')
        except Exception as e:
            db.session.rollback()
            flash(f'Error updating settings: {str(e)}', 'error')
        
        return redirect(url_for('aws_settings'))
    
    return render_template('aws_settings.html', user=user)

############################################################ Backup Operations ############################################################

@app.route('/bulk-export-amis', methods=['POST'])
def bulk_export_amis():
    try:
        data = request.get_json()
        if not data:
            flash('Invalid request data.', 'error')
            return redirect('/')
            
        instance_ids = data.get('instances', [])
        if not instance_ids:
            flash('No instances selected for export.', 'warning')
            return redirect('/')
        
        amis = Backup.query.filter(Backup.instance_id.in_(instance_ids)).all()
        if not amis:
            flash('No AMIs found for selected instances.', 'warning')
            return redirect('/')

        si = StringIO()
        try:
            writer = csv.writer(si)
            writer.writerow(['AMI ID', 'Instance Name', 'Instance ID', 'Region', 'Timestamp', 'Status'])
            for ami in amis:
                writer.writerow([ami.ami_id, ami.instance_name, ami.instance_id, ami.region, ami.timestamp, ami.status])

            output = si.getvalue()
            response = make_response(output)
            response.headers["Content-Disposition"] = "attachment; filename=amis_export.csv"
            response.headers["Content-Type"] = "text/csv"
            return response
        finally:
            si.close()
            
    except Exception as e:
        flash(f'Error during export: {str(e)}', 'error')
        return redirect('/')


@app.route('/bulk-tag-amis', methods=['POST'])
def bulk_tag_amis():
    try:
        data = request.get_json()
        if not data:
            flash('Invalid request data.', 'error')
            return redirect('/')
            
        instance_ids = data.get('instances', [])
        tag_key = data.get('tag_key', '').strip()
        tag_value = data.get('tag_value', '').strip()
        
        # Validate required parameters
        if not instance_ids:
            flash('No instances selected for tagging.', 'warning')
            return redirect('/')
            
        if not tag_key or not tag_value:
            flash('Both tag key and tag value are required.', 'error')
            return redirect('/')

        tagged_amis = []
        errors = []

        # Get all instances at once to reduce database queries
        instances = Instance.query.filter(Instance.instance_id.in_(instance_ids)).all()
        instance_dict = {inst.instance_id: inst for inst in instances}

        for inst_id in instance_ids:
            inst = instance_dict.get(inst_id)
            if not inst:
                errors.append(f"Instance {inst_id} not found.")
                continue
                
            backups = Backup.query.filter_by(instance_id=inst_id).all()
            if not backups:
                errors.append(f"No backups found for instance {inst_id}.")
                continue
                
            try:
                ec2 = boto3.client(
                    'ec2',
                    region_name=inst.region,
                    aws_access_key_id=inst.access_key,
                    aws_secret_access_key=inst.secret_key
                )
                
                for backup in backups:
                    try:
                        ec2.create_tags(
                            Resources=[backup.ami_id],
                            Tags=[{'Key': tag_key, 'Value': tag_value}]
                        )
                        tagged_amis.append(backup.ami_id)
                    except Exception as e:
                        errors.append(f"Failed to tag {backup.ami_id}: {str(e)}")
                        
            except Exception as e:
                errors.append(f"Failed to connect to AWS for instance {inst_id}: {str(e)}")

        # Prepare response message
        if tagged_amis:
            msg = f"Successfully tagged {len(tagged_amis)} AMIs: {', '.join(tagged_amis[:5])}"
            if len(tagged_amis) > 5:
                msg += f" and {len(tagged_amis) - 5} more"
        else:
            msg = "No AMIs were tagged"

        if errors:
            msg += f" | {len(errors)} errors occurred"
            if len(errors) <= 3:
                msg += ": " + " | ".join(errors)
            flash(msg, "warning")
        else:
            flash(msg, "success")
            
    except Exception as e:
        flash(f'Unexpected error during tagging: {str(e)}', 'error')
        
    return redirect('/')  # or your backup records page


############################################################ AWS AMI Creators ############################################################

@app.route('/start-backup/<instance_id>', methods=['POST'])
def start_backup(instance_id):
    backup = None
    try:
        inst = Instance.query.filter_by(instance_id=instance_id).first_or_404()
        retention_days = int(inst.retention_days) if hasattr(inst, 'retention_days') and inst.retention_days else 7
        aws_region = inst.region
        aws_access_key = inst.access_key
        aws_secret_key = inst.secret_key

        if not all([aws_region, aws_access_key, aws_secret_key]):
            flash(f"Missing AWS credentials for instance {instance_id}.", "danger")
            return redirect(url_for('manage_instances'))

        ec2 = boto3.client(
            'ec2',
            region_name=aws_region,
            aws_access_key_id=aws_access_key,
            aws_secret_access_key=aws_secret_key
        )

        # Get instance name
        tags_response = ec2.describe_tags(
            Filters=[
                {'Name': 'resource-id', 'Values': [instance_id]},
                {'Name': 'key', 'Values': ['Name']}
            ]
        )
        instance_name = None
        for tag in tags_response.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break

        if not instance_name:
            flash(f"Could not find 'Name' tag for {instance_id}.", "danger")
            return redirect(url_for('manage_instances'))

        # Create AMI
        zone = pytz.timezone('Asia/Kolkata')
        timestamp_str = datetime.now(zone).strftime("%Y_%m_%d_%I_%M_%p")
        ami_name = f"{instance_name}_{timestamp_str}"
        
        ami_response = ec2.create_image(
            InstanceId=instance_id,
            Name=ami_name,
            NoReboot=True
        )
        ami_id = ami_response['ImageId']

        # Create backup record with AMI ID from the start
        backup = Backup(
            instance_id=instance_id,
            instance_name=instance_name,
            ami_id=ami_id,
            ami_name=ami_name, 
            timestamp=datetime.utcnow(),
            status='Pending',
            region=aws_region,
            retention_days=retention_days
        )
        db.session.add(backup)
        db.session.commit()

        # Tag the AMI
        ec2.create_tags(
            Resources=[ami_id],
            Tags=[
                {'Key': 'CreatedBy', 'Value': 'AutoBackup'},
                {'Key': 'InstanceName', 'Value': instance_name},
                {'Key': 'RetentionDays', 'Value': str(retention_days)}
            ]
        )

        # Update backup record to Success
        backup.status = 'Success'
        db.session.commit()

        # Cleanup old AMIs
        cleanup_old_amis(ec2, instance_name, retention_days)

        flash(f"Manual backup completed for instance {instance_id} (AMI: {ami_id})", "success")
        
    except Exception as e:
        # If backup record exists, update status to Failed
        if backup:
            try:
                backup.status = 'Failed'
                db.session.commit()
            except:
                db.session.rollback()
        flash(f"Backup failed: {str(e)}", "danger")

    return redirect(url_for('manage_instances'))


def get_effective_setting(instance_value, global_value):
    """Get effective setting value, preferring instance over global"""
    return instance_value if instance_value not in [None, '', 0] else global_value


# Scheduler config
class Config:
    SCHEDULER_API_ENABLED = True

app.config.from_object(Config())
scheduler = APScheduler()
scheduler.init_app(app)


def cleanup_old_amis(ec2, instance_name, retention_days):
    """Clean up AMIs older than retention period"""
    try:
        images_response = ec2.describe_images(
            Owners=['self'],
            Filters=[
                {'Name': 'tag:CreatedBy', 'Values': ['AutoBackup']},
                {'Name': 'tag:InstanceName', 'Values': [instance_name]}
            ]
        )
        
        now = datetime.now(timezone.utc)
        deleted_count = 0
        
        for image in images_response['Images']:
            try:
                creation_date = datetime.strptime(
                    image['CreationDate'], "%Y-%m-%dT%H:%M:%S.%fZ"
                ).replace(tzinfo=timezone.utc)
                age_days = (now - creation_date).days
                
                if age_days > retention_days:
                    ami_id_to_delete = image['ImageId']
                    
                    # Delete associated snapshots first
                    for mapping in image.get('BlockDeviceMappings', []):
                        ebs = mapping.get('Ebs')
                        if ebs and 'SnapshotId' in ebs:
                            try:
                                ec2.delete_snapshot(SnapshotId=ebs['SnapshotId'])
                                print(f"Deleted snapshot {ebs['SnapshotId']} for AMI {ami_id_to_delete}")
                            except Exception as e:
                                print(f"Could not delete snapshot {ebs['SnapshotId']}: {e}")
                    
                    # Deregister the AMI
                    ec2.deregister_image(ImageId=ami_id_to_delete)
                    print(f"Deregistered AMI {ami_id_to_delete} (age: {age_days} days)")
                    deleted_count += 1
                    
                    # Remove from database
                    Backup.query.filter_by(ami_id=ami_id_to_delete).delete()
                    
            except Exception as e:
                print(f"Error processing AMI {image.get('ImageId', 'unknown')}: {e}")
                
        if deleted_count > 0:
            db.session.commit()
            print(f"Cleaned up {deleted_count} old AMIs for {instance_name}")
            
    except Exception as e:
        print(f"Error during cleanup for {instance_name}: {e}")


def backup_instance(instance_id):
    """Scheduled backup function for individual instance"""
    with app.app_context():
        try:
            inst = Instance.query.filter_by(instance_id=instance_id).first()
            global_config = BackupSettings.query.first()
            
            if not inst:
                print(f"Instance {instance_id} not found")
                return
                
            if not global_config:
                print(f"Global backup configuration missing")
                return

            retention_days = get_effective_setting(inst.retention_days, global_config.retention_days)
            region = inst.region
            access_key = inst.access_key
            secret_key = inst.secret_key

            if not all([region, access_key, secret_key]):
                print(f"Missing AWS credentials for instance {instance_id}")
                return

            ec2 = boto3.client(
                'ec2',
                region_name=region,
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key
            )
            
            # Get instance name from AWS tags
            tags_response = ec2.describe_tags(
                Filters=[
                    {'Name': 'resource-id', 'Values': [instance_id]},
                    {'Name': 'key', 'Values': ['Name']}
                ]
            )
            instance_name = None
            for tag in tags_response.get('Tags', []):
                if tag['Key'] == 'Name':
                    instance_name = tag['Value']
                    break
                    
            if not instance_name:
                print(f"No name tag found for instance {instance_id}")
                return

            # Create AMI
            zone = pytz.timezone('Asia/Kolkata')
            timestamp_str = datetime.now(zone).strftime("%Y_%m_%d_%I_%M_%p")
            ami_name = f"{instance_name}_{timestamp_str}"
            
            ami_response = ec2.create_image(
                InstanceId=instance_id,
                Name=ami_name,
                NoReboot=True
            )
            ami_id = ami_response['ImageId']

            # Tag the AMI
            ec2.create_tags(
                Resources=[ami_id],
                Tags=[
                    {'Key': 'CreatedBy', 'Value': 'AutoBackup'},
                    {'Key': 'InstanceName', 'Value': instance_name},
                    {'Key': 'RetentionDays', 'Value': str(retention_days)}
                ]
            )

            # Record backup in DB
            backup = Backup(
                instance_id=instance_id,
                instance_name=instance_name,
                ami_id=ami_id,
                ami_name=ami_name,
                timestamp=datetime.utcnow(),
                status='Success',
                region=region,
                retention_days=retention_days
            )
            db.session.add(backup)
            db.session.commit()

            print(f"Backup success for {instance_id} at {datetime.utcnow()}")

            # Cleanup old AMIs and snapshots
            cleanup_old_amis(ec2, instance_name, retention_days)

        except Exception as e:
            print(f"Backup failed for {instance_id}: {str(e)}")
            # Record failure in DB
            try:
                backup = Backup(
                    instance_id=instance_id,
                    instance_name=instance_name or 'Unknown',
                    ami_id=None,
                    ami_name=f"Failed_backup_{datetime.utcnow().strftime('%Y_%m_%d_%H_%M')}",
                    timestamp=datetime.utcnow(),
                    status='Failed',
                    region=region if 'region' in locals() else 'unknown',
                    retention_days=retention_days if 'retention_days' in locals() else 7
                )
                db.session.add(backup)
                db.session.commit()
            except Exception as db_error:
                print(f"Failed to record backup failure: {db_error}")
############################################################ Scheduling ############################################################

@app.route('/schedules', endpoint='schedules')
def schedules():
    try:
        # Check if user is logged in
        if 'user_id' not in session:
            return redirect(url_for('login'))
        
        # Get user information
        user_id = session['user_id']
        
        # You'll need to replace this with your actual user retrieval function
        # This is just a placeholder - adjust based on your database structure
        try:
            user = get_user_by_id(user_id)  # Replace with your actual function
        except NameError:
            # If get_user_by_id doesn't exist, create a basic version
            flash('User data retrieval function not implemented', 'error')
            return render_template('schedules.html', 
                                 scheduled_instances=[],
                                 eventbridge_rules=[],
                                 current_time=datetime.now(pytz.UTC))
        
        if not user:
            flash('User not found', 'error')
            return redirect(url_for('login'))
        
        # Check AWS credentials
        aws_access_key = user.get('aws_access_key_id')
        aws_secret_key = user.get('aws_secret_access_key')
        aws_region = user.get('region', 'us-east-1')
        
        if not aws_access_key or not aws_secret_key:
            flash('AWS credentials not configured. Please update your settings.', 'error')
            return render_template('schedules.html', 
                                 scheduled_instances=[],
                                 eventbridge_rules=[],
                                 current_time=datetime.now(pytz.UTC))
        
        # Initialize AWS clients
        try:
            session_aws = boto3.Session(
                aws_access_key_id=aws_access_key,
                aws_secret_access_key=aws_secret_key,
                region_name=aws_region
            )
            
            ec2 = session_aws.client('ec2')
            events_client = session_aws.client('events')
        except Exception as e:
            flash(f'Error connecting to AWS: {str(e)}', 'error')
            return render_template('schedules.html', 
                                 scheduled_instances=[],
                                 eventbridge_rules=[],
                                 current_time=datetime.now(pytz.UTC))
        
        # Get instances with backup schedules
        scheduled_instances = []
        eventbridge_rules = []
        
        try:
            # Get all instances
            instances_response = ec2.describe_instances()
            
            for reservation in instances_response['Reservations']:
                for instance in reservation['Instances']:
                    if instance['State']['Name'] in ['running', 'stopped']:
                        instance_id = instance['InstanceId']
                        instance_name = instance_id  # Default to instance ID
                        backup_schedule = None
                        
                        # Get instance name and backup schedule from tags
                        for tag in instance.get('Tags', []):
                            if tag['Key'] == 'Name':
                                instance_name = tag['Value']
                            elif tag['Key'] == 'BackupSchedule':
                                backup_schedule = tag['Value']
                        
                        if backup_schedule:
                            # Calculate next run time
                            next_run = calculate_next_run_safe(backup_schedule)
                            
                            # Get EventBridge rule status
                            rule_name = f"backup-{instance_id}"
                            rule_status = get_rule_status_safe(events_client, rule_name)
                            
                            scheduled_instances.append({
                                'instance_id': instance_id,
                                'instance_name': instance_name,
                                'instance_type': instance['InstanceType'],
                                'state': instance['State']['Name'],
                                'schedule': backup_schedule,
                                'next_run': next_run,
                                'rule_status': rule_status,
                                'timezone': user.get('timezone', 'UTC')
                            })
            
            # Get EventBridge rules
            eventbridge_rules = get_eventbridge_rules_safe(events_client)
            
        except Exception as e:
            flash(f'Error retrieving instance data: {str(e)}', 'error')
            print(f"Instance retrieval error: {traceback.format_exc()}")
        
        return render_template('schedules.html', 
                             scheduled_instances=scheduled_instances,
                             eventbridge_rules=eventbridge_rules,
                             current_time=datetime.now(pytz.UTC))
        
    except Exception as e:
        # Log the full error for debugging
        print(f"Schedules route error: {traceback.format_exc()}")
        flash(f'An error occurred: {str(e)}', 'error')
        return render_template('schedules.html', 
                             scheduled_instances=[],
                             eventbridge_rules=[],
                             current_time=datetime.now(pytz.UTC))

def calculate_next_run_safe(cron_expression):
    """Safely calculate the next run time for a cron expression"""
    if not CRONITER_AVAILABLE:
        return None
    
    try:
        # Handle different cron formats
        if cron_expression.startswith('cron(') and cron_expression.endswith(')'):
            # AWS EventBridge format: cron(0 2 * * ? *)
            cron_parts = cron_expression[5:-1].split()
            if len(cron_parts) == 6:
                # Convert AWS format to standard cron (remove year field, replace ? with *)
                standard_cron = ' '.join(cron_parts[:5]).replace('?', '*')
            else:
                standard_cron = cron_expression[5:-1]
        else:
            # Assume standard cron format
            standard_cron = cron_expression
        
        # Create croniter object
        now = datetime.now(pytz.UTC)
        cron = croniter(standard_cron, now)
        next_run = cron.get_next(datetime)
        
        return next_run
    except Exception as e:
        print(f"Error calculating next run for {cron_expression}: {e}")
        return None

def get_rule_status_safe(events_client, rule_name):
    """Safely get the status of an EventBridge rule"""
    try:
        response = events_client.describe_rule(Name=rule_name)
        return {
            'exists': True,
            'state': response['State'],
            'description': response.get('Description', ''),
            'schedule': response.get('ScheduleExpression', '')
        }
    except events_client.exceptions.ResourceNotFoundException:
        return {'exists': False, 'state': 'NOT_FOUND'}
    except Exception as e:
        print(f"Error getting rule status for {rule_name}: {e}")
        return {'exists': False, 'state': 'ERROR', 'error': str(e)}

def get_eventbridge_rules_safe(events_client):
    """Safely get all EventBridge rules for backup operations"""
    try:
        response = events_client.list_rules()
        backup_rules = []
        
        for rule in response['Rules']:
            if rule['Name'].startswith('backup-') or 'backup' in rule['Name'].lower():
                # Get targets for this rule
                try:
                    targets_response = events_client.list_targets_by_rule(Rule=rule['Name'])
                    target_count = len(targets_response['Targets'])
                except Exception:
                    target_count = 0
                
                backup_rules.append({
                    'name': rule['Name'],
                    'state': rule['State'],
                    'schedule': rule.get('ScheduleExpression', ''),
                    'description': rule.get('Description', ''),
                    'targets': target_count,
                    'next_run': calculate_next_run_safe(rule.get('ScheduleExpression', '')) if rule.get('ScheduleExpression') else None
                })
        
        return backup_rules
    except Exception as e:
        print(f"Error getting EventBridge rules: {e}")
        return []

def time_until_safe(target_time):
    """Calculate human-readable time until target time"""
    if not target_time:
        return "Unknown"
    
    try:
        now = datetime.now(pytz.UTC)
        if target_time.tzinfo is None:
            target_time = pytz.UTC.localize(target_time)
        
        diff = target_time - now
        
        if diff.total_seconds() < 0:
            return "Overdue"
        
        days = diff.days
        hours, remainder = divmod(diff.seconds, 3600)
        minutes, _ = divmod(remainder, 60)
        
        if days > 0:
            return f"{days}d {hours}h {minutes}m"
        elif hours > 0:
            return f"{hours}h {minutes}m"
        else:
            return f"{minutes}m"
    except Exception as e:
        print(f"Error calculating time until: {e}")
        return "Unknown"

# Add this as a template filter
@app.template_filter('time_until')
def time_until_filter(target_time):
    return time_until_safe(target_time)

# If you don't have a get_user_by_id function, here's a basic template
# Replace this with your actual user retrieval logic
def get_user_by_id(user_id):
    """
    Retrieve user data from database using SQLAlchemy
    """
    try:
        user = User.query.get(user_id)
        if user:
            return {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                'aws_access_key_id': user.aws_access_key_id,
                'aws_secret_access_key': user.aws_secret_access_key,
                'region': user.region or 'us-east-1',
                'timezone': user.timezone or 'UTC',
                'two_factor_enabled': user.two_factor_enabled
            }
        return None
    except Exception as e:
        print(f"Error retrieving user: {e}")
        return None

def get_user_by_id_temp(user_id):
    """
    Temporary function while you update your database
    This gets basic user info and uses session data for AWS credentials
    """
    try:
        user = User.query.get(user_id)
        if user:
            return {
                'id': user.id,
                'username': user.username,
                'email': user.email,
                # Use session data temporarily until database is updated
                'aws_access_key_id': session.get('aws_access_key_id'),
                'aws_secret_access_key': session.get('aws_secret_access_key'),
                'region': session.get('region', 'us-east-1'),
                'timezone': session.get('timezone', 'UTC')
            }
        return None
    except Exception as e:
        print(f"Error retrieving user: {e}")
        return None

def after_successful_login(user):
    """Add this to your login route after password verification"""
    session['user_id'] = user.id
    session['username'] = user.username
    # If you have AWS credentials stored elsewhere temporarily, add them:
    # session['aws_access_key_id'] = user.aws_access_key_id
    # session['aws_secret_access_key'] = user.aws_secret_access_key
    session.permanent = True

# Add this temporary debug route to identify the issue
@app.route('/schedules-debug')
def schedules_debug():
    """Debug route to identify the schedules page issue"""
    debug_info = {
        'session_data': dict(session),
        'imports_available': {},
        'user_data': None,
        'error': None
    }
    
    try:
        # Check imports
        try:
            import boto3
            debug_info['imports_available']['boto3'] = True
        except ImportError:
            debug_info['imports_available']['boto3'] = False
        
        try:
            from croniter import croniter
            debug_info['imports_available']['croniter'] = True
        except ImportError:
            debug_info['imports_available']['croniter'] = False
        
        try:
            import pytz
            debug_info['imports_available']['pytz'] = True
        except ImportError:
            debug_info['imports_available']['pytz'] = False
        
        # Check session
        if 'user_id' not in session:
            debug_info['error'] = 'No user_id in session'
            return jsonify(debug_info)
        
        # Try to get user data
        user_id = session['user_id']
        try:
            user = get_user_by_id(user_id)
            debug_info['user_data'] = {
                'exists': user is not None,
                'has_aws_keys': bool(user.get('aws_access_key_id') and user.get('aws_secret_access_key')) if user else False,
                'region': user.get('region') if user else None
            }
        except Exception as e:
            debug_info['error'] = f'Error getting user data: {str(e)}'
            debug_info['user_data'] = {'error': str(e)}
        
        return jsonify(debug_info)
        
    except Exception as e:
        debug_info['error'] = f'Debug route error: {str(e)}'
        return jsonify(debug_info)

# Minimal schedules route for testing
@app.route('/schedules-minimal')
def schedules_minimal():
    """Minimal version for testing"""
    try:
        if 'user_id' not in session:
            return redirect(url_for('login'))
        
        return render_template('schedules.html', 
                             scheduled_instances=[],
                             eventbridge_rules=[],
                             current_time=datetime.now())
        
    except Exception as e:
        return f"Error: {str(e)}"

# Simple test route
@app.route('/schedules-test')
def schedules_test():
    """Very basic test"""
    return "Schedules route is working!"
############################################################ Backup Scheduling ############################################################

def schedule_all_instance_backups():
    """Schedule backup jobs for all active instances."""
    try:
        logger.info("Scheduling backup jobs for all instances")
        
        # Get backup settings
        settings = BackupSettings.query.first()
        if not settings:
            logger.warning("No backup settings found")
            return
        
        # Get all active instances
        instances = Instance.query.filter_by(is_active=True).all()
        
        for instance in instances:
            try:
                schedule_instance_backup(instance, settings)
            except Exception as e:
                logger.error(f"Failed to schedule backup for instance {instance.instance_id}: {str(e)}")
        
        logger.info(f"Scheduled backups for {len(instances)} instances")
        
    except Exception as e:
        logger.error(f"Error in schedule_all_instance_backups: {str(e)}")

def schedule_instance_backup(instance, settings):
    """Schedule backup job for a specific instance."""
    try:
        job_id = f"backup_{instance.instance_id}"
        
        # Remove existing job if it exists
        try:
            scheduler.remove_job(job_id)
        except:
            pass  # Job doesn't exist, which is fine
        
        # Determine trigger based on frequency
        if settings.backup_frequency == 'daily':
            trigger = 'interval'
            trigger_args = {'hours': 24}
        elif settings.backup_frequency == 'weekly':
            trigger = 'interval'
            trigger_args = {'weeks': 1}
        elif settings.backup_frequency == 'monthly':
            trigger = 'interval'
            trigger_args = {'weeks': 4}
        else:
            logger.error(f"Unknown backup frequency: {settings.backup_frequency}")
            return
        
        # Add the job
        scheduler.add_job(
            id=job_id,
            func=perform_instance_backup,
            args=[instance.instance_id],
            trigger=trigger,
            replace_existing=True,
            **trigger_args
        )
        
        # Record the job in database
        existing_job = BackupJob.query.filter_by(job_id=job_id).first()
        if not existing_job:
            backup_job = BackupJob(
                instance_id=instance.instance_id,
                job_id=job_id,
                status='scheduled'
            )
            db.session.add(backup_job)
            db.session.commit()
        
        logger.info(f"Scheduled {settings.backup_frequency} backup for instance {instance.instance_id}")
        
    except Exception as e:
        logger.error(f"Error scheduling backup for instance {instance.instance_id}: {str(e)}")

def perform_instance_backup(instance_id):
    """Perform backup for a specific instance."""
    try:
        logger.info(f"Starting backup for instance {instance_id}")
        
        # Get instance details
        instance = Instance.query.filter_by(instance_id=instance_id).first()
        if not instance:
            logger.error(f"Instance {instance_id} not found in database")
            return
        
        # Update job status
        job_id = f"backup_{instance_id}"
        backup_job = BackupJob.query.filter_by(job_id=job_id).first()
        if backup_job:
            backup_job.status = 'running'
            db.session.commit()
        
        # Create AWS client
        ec2_client = boto3.client(
            'ec2',
            region_name=instance.region,
            aws_access_key_id=instance.access_key,
            aws_secret_access_key=instance.secret_key
        )
        
        # Create snapshot (simplified - you might want to get all volumes)
        response = ec2_client.describe_instances(InstanceIds=[instance_id])
        volumes = []
        
        for reservation in response['Reservations']:
            for inst in reservation['Instances']:
                for block_device in inst.get('BlockDeviceMappings', []):
                    if 'Ebs' in block_device:
                        volumes.append(block_device['Ebs']['VolumeId'])
        
        # Create snapshots for all volumes
        snapshot_ids = []
        for volume_id in volumes:
            snapshot_response = ec2_client.create_snapshot(
                VolumeId=volume_id,
                Description=f"Automated backup for {instance_id} - {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')}"
            )
            snapshot_ids.append(snapshot_response['SnapshotId'])
            logger.info(f"Created snapshot {snapshot_response['SnapshotId']} for volume {volume_id}")
        
        # Update job status
        if backup_job:
            backup_job.status = 'completed'
            backup_job.completed_at = datetime.utcnow()
            db.session.commit()
        
        logger.info(f"Backup completed for instance {instance_id}. Created {len(snapshot_ids)} snapshots.")
        
        # Clean up old snapshots based on retention policy
        cleanup_old_snapshots(instance, ec2_client)
        
    except Exception as e:
        logger.error(f"Error performing backup for instance {instance_id}: {str(e)}")
        
        # Update job status to failed
        job_id = f"backup_{instance_id}"
        backup_job = BackupJob.query.filter_by(job_id=job_id).first()
        if backup_job:
            backup_job.status = 'failed'
            backup_job.completed_at = datetime.utcnow()
            db.session.commit()

def cleanup_old_snapshots(instance, ec2_client):
    """Clean up old snapshots based on retention policy."""
    try:
        settings = BackupSettings.query.first()
        if not settings:
            return
        
        cutoff_date = datetime.utcnow() - timedelta(days=settings.retention_days)
        
        # Get snapshots created by this application
        snapshots = ec2_client.describe_snapshots(OwnerIds=['self'])
        
        for snapshot in snapshots['Snapshots']:
            # Check if snapshot is from automated backup and older than retention period
            if (snapshot.get('Description', '').startswith('Automated backup for') and 
                snapshot['StartTime'].replace(tzinfo=None) < cutoff_date):
                
                try:
                    ec2_client.delete_snapshot(SnapshotId=snapshot['SnapshotId'])
                    logger.info(f"Deleted old snapshot {snapshot['SnapshotId']}")
                except Exception as e:
                    logger.warning(f"Failed to delete snapshot {snapshot['SnapshotId']}: {str(e)}")
        
    except Exception as e:
        logger.error(f"Error cleaning up old snapshots: {str(e)}")


@app.route('/reschedule-backups')
def reschedule_backups():
    try:
        schedule_all_instance_backups()
        return "Rescheduled all instance backups!", 200
    except Exception as e:
        return f"Error rescheduling backups: {str(e)}", 500


@app.route('/search-suggestions')
def search_suggestions():
    try:
        # Gather unique instance names, instance IDs, and AMI IDs from the database
        instance_names = [i.instance_name for i in Instance.query.with_entities(Instance.instance_name).distinct() if i.instance_name]
        instance_ids = [i.instance_id for i in Instance.query.with_entities(Instance.instance_id).distinct() if i.instance_id]
        ami_ids = [b.ami_id for b in Backup.query.with_entities(Backup.ami_id).distinct() if b.ami_id]
        
        # Combine and deduplicate
        suggestions = list(set(instance_names + instance_ids + ami_ids))
        return jsonify(suggestions)
    except Exception as e:
        return jsonify([]), 500


@app.route('/api/instances')
def api_instances():
    try:
        instances = Instance.query.all()
        return jsonify([{
            'instance_id': i.instance_id, 
            'instance_name': i.instance_name or 'Unknown'
        } for i in instances])
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/api/amis')
def api_amis():
    try:
        instance_ids_param = request.args.get('instances', '')
        if not instance_ids_param:
            return jsonify([])
            
        instance_ids = [id.strip() for id in instance_ids_param.split(',') if id.strip()]
        if not instance_ids:
            return jsonify([])
            
        amis = Backup.query.filter(Backup.instance_id.in_(instance_ids)).all()
        return jsonify([{
            'ami_id': b.ami_id, 
            'instance_name': b.instance_name or 'Unknown'
        } for b in amis if b.ami_id])
    except Exception as e:
        return jsonify({'error': str(e)}), 500


@app.route('/bulk-delete-amis', methods=['POST'])
def bulk_delete_amis():
    try:
        data = request.get_json()
        if not data:
            flash('Invalid request data.', 'error')
            return redirect('/')
            
        instance_ids = data.get('instances', [])
        if not instance_ids:
            flash('No instances selected for deletion.', 'warning')
            return redirect('/')
            
        deleted_amis = []
        errors = []

        # Get all instances at once to reduce database queries
        instances = Instance.query.filter(Instance.instance_id.in_(instance_ids)).all()
        instance_dict = {inst.instance_id: inst for inst in instances}

        for inst_id in instance_ids:
            inst = instance_dict.get(inst_id)
            if not inst:
                errors.append(f"Instance {inst_id} not found")
                continue
                
            try:
                ec2 = boto3.client(
                    'ec2',
                    region_name=inst.region,
                    aws_access_key_id=inst.access_key,
                    aws_secret_access_key=inst.secret_key
                )
                
                backups = Backup.query.filter_by(instance_id=inst_id).all()
                for backup in backups:
                    if not backup.ami_id:
                        continue
                        
                    try:
                        # Get AMI details before deleting
                        try:
                            image_response = ec2.describe_images(ImageIds=[backup.ami_id])
                            if image_response['Images']:
                                image = image_response['Images'][0]
                                
                                # Delete associated snapshots
                                for mapping in image.get('BlockDeviceMappings', []):
                                    ebs = mapping.get('Ebs')
                                    if ebs and 'SnapshotId' in ebs:
                                        try:
                                            ec2.delete_snapshot(SnapshotId=ebs['SnapshotId'])
                                        except Exception as e:
                                            print(f"Could not delete snapshot {ebs['SnapshotId']}: {e}")
                        except Exception as e:
                            print(f"Could not describe image {backup.ami_id}: {e}")
                        
                        # Deregister AMI
                        ec2.deregister_image(ImageId=backup.ami_id)
                        deleted_amis.append(backup.ami_id)
                        
                    except Exception as e:
                        errors.append(f"Error deleting AMI {backup.ami_id}: {str(e)}")

                # Delete all Backup records for this instance
                Backup.query.filter_by(instance_id=inst_id).delete(synchronize_session=False)
                
            except Exception as e:
                errors.append(f"Error processing instance {inst_id}: {str(e)}")

        # Commit all database changes
        try:
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            errors.append(f"Database error: {str(e)}")

        # Provide feedback
        if deleted_amis:
            msg = f"Successfully deleted {len(deleted_amis)} AMIs"
            if len(deleted_amis) <= 5:
                msg += f": {', '.join(deleted_amis)}"
            flash(msg, "success")
            
        if errors:
            error_msg = f"{len(errors)} errors occurred"
            if len(errors) <= 3:
                error_msg += ": " + " | ".join(errors)
            flash(error_msg, "danger")

    except Exception as e:
        flash(f"Unexpected error during bulk deletion: {str(e)}", "error")

    return redirect('/')


@app.route('/api/schedules')
def get_schedules():
    try:
        schedules = Schedule.query.all()
        result = []
        
        for schedule in schedules:
            inst = Instance.query.filter_by(instance_id=schedule.instance_id).first()
            result.append({
                "id": schedule.job_id,
                "name": inst.instance_name if inst and inst.instance_name else "Unknown",
                "instance_id": schedule.instance_id,
                "next_run_time": schedule.next_run_time.isoformat() if schedule.next_run_time else None,
                "frequency": schedule.frequency
            })
            
        return jsonify(result)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

############################################################ Error Handlers ############################################################

@app.errorhandler(404)
def not_found_error(error):
    return jsonify(success=False, error='Endpoint not found'), 404

@app.errorhandler(500)
def internal_error(error):
    logger.error(f"Internal server error: {str(error)}")
    db.session.rollback()
    return jsonify(success=False, error='Internal server error'), 500

############################################################ Application Startup ############################################################

def create_tables():
    """Create database tables."""
    try:
        db.create_all()
        logger.info("Database tables created successfully")
    except Exception as e:
        logger.error(f"Error creating database tables: {str(e)}")

def initialize_scheduler():
    """Initialize and start the scheduler."""
    try:
        scheduler.init_app(app)
        scheduler.start()
        
        # Add periodic job to sync backup schedules
        scheduler.add_job(
            id='sync_backup_schedules',
            func=schedule_all_instance_backups,
            trigger='interval',
            minutes=5,
            replace_existing=True
        )
        
        logger.info("Scheduler initialized successfully")
        return True
        
    except Exception as e:
        logger.error(f"Error initializing scheduler: {str(e)}")
        return False

############## delete ami working  #############################
@app.route('/delete-ami/<ami_id>', methods=['POST'])
def delete_ami(ami_id):
    backup = None
    try:
        # Validate AMI ID format
        if not ami_id or not ami_id.startswith('ami-'):
            flash("Invalid AMI ID format.", "danger")
            return redirect(url_for('dashboard'))

        # Find backup record
        backup = Backup.query.filter_by(ami_id=ami_id).first()
        if not backup:
            flash(f"AMI record {ami_id} not found in database.", "danger")
            return redirect(url_for('dashboard'))

        # Find associated instance
        instance = Instance.query.filter_by(instance_id=backup.instance_id).first()
        if not instance:
            flash(f"Instance record not found for AMI {ami_id}.", "danger")
            return redirect(url_for('dashboard'))

        # Validate AWS credentials
        if not all([instance.region, instance.access_key, instance.secret_key]):
            flash(f"Missing AWS credentials for instance {backup.instance_id}.", "danger")
            return redirect(url_for('dashboard'))

        # Initialize EC2 client
        ec2 = boto3.client(
            'ec2',
            region_name=instance.region,
            aws_access_key_id=instance.access_key,
            aws_secret_access_key=instance.secret_key
        )

        # Check if AMI exists in AWS
        try:
            images_response = ec2.describe_images(ImageIds=[ami_id])
            images = images_response.get('Images', [])
        except Exception as e:
            # AMI might not exist in AWS but still in our database
            if 'InvalidAMIID.NotFound' in str(e) or 'does not exist' in str(e).lower():
                flash(f"AMI {ami_id} not found in AWS (may have been deleted externally). Removing from database.", "warning")
                db.session.delete(backup)
                db.session.commit()
                return redirect(url_for('dashboard'))
            else:
                raise e

        deleted_snapshots = []
        snapshot_errors = []

        # If AMI exists in AWS, get snapshot info before deregistration
        if images:
            image = images[0]
            
            # Collect snapshot IDs before deregistering AMI
            snapshot_ids = []
            for mapping in image.get('BlockDeviceMappings', []):
                ebs = mapping.get('Ebs')
                if ebs and 'SnapshotId' in ebs:
                    snapshot_ids.append(ebs['SnapshotId'])

            # Deregister the AMI first
            try:
                ec2.deregister_image(ImageId=ami_id)
                flash(f"AMI {ami_id} deregistered successfully.", "success")
            except Exception as e:
                flash(f"Failed to deregister AMI {ami_id}: {str(e)}", "danger")
                return redirect(url_for('dashboard'))

            # Delete associated snapshots
            for snapshot_id in snapshot_ids:
                try:
                    ec2.delete_snapshot(SnapshotId=snapshot_id)
                    deleted_snapshots.append(snapshot_id)
                except Exception as e:
                    error_msg = str(e)
                    # Handle common snapshot deletion errors
                    if 'InvalidSnapshot.InUse' in error_msg:
                        snapshot_errors.append(f"Snapshot {snapshot_id} is in use by another resource")
                    elif 'InvalidSnapshot.NotFound' in error_msg:
                        snapshot_errors.append(f"Snapshot {snapshot_id} not found (may have been deleted)")
                    else:
                        snapshot_errors.append(f"Failed to delete snapshot {snapshot_id}: {error_msg}")

        # Remove backup record from database
        try:
            db.session.delete(backup)
            db.session.commit()
        except Exception as e:
            db.session.rollback()
            flash(f"Failed to remove AMI record from database: {str(e)}", "danger")
            return redirect(url_for('dashboard'))

        # Provide comprehensive feedback
        success_messages = []
        if deleted_snapshots:
            if len(deleted_snapshots) <= 3:
                success_messages.append(f"Deleted snapshots: {', '.join(deleted_snapshots)}")
            else:
                success_messages.append(f"Deleted {len(deleted_snapshots)} snapshots: {', '.join(deleted_snapshots[:3])} and {len(deleted_snapshots) - 3} more")

        if success_messages:
            flash(" | ".join(success_messages), "success")

        if snapshot_errors:
            if len(snapshot_errors) <= 2:
                flash("Snapshot warnings: " + " | ".join(snapshot_errors), "warning")
            else:
                flash(f"Snapshot warnings: {len(snapshot_errors)} issues occurred. Some snapshots may still exist.", "warning")

    except Exception as e:
        error_msg = f"Error deleting AMI {ami_id}: {str(e)}"
        flash(error_msg, "danger")
        
        # Log the error for debugging
        print(f"AMI deletion error: {error_msg}")
        
        # Rollback any database changes
        if backup:
            try:
                db.session.rollback()
            except:
                pass

    return redirect(url_for('dashboard'))

############################################################ AWS Checker ############################################################

@app.route('/check-instance', methods=['POST'])
def check_instance():
    """Check if an AWS EC2 instance exists and return its details."""
    try:
        data = request.get_json()
        if not data:
            return jsonify(success=False, error='No JSON data provided'), 400

        # Validate required fields
        required_fields = ['instance_id', 'access_key', 'secret_key', 'region']
        missing_fields = [field for field in required_fields if not data.get(field)]
        
        if missing_fields:
            return jsonify(
                success=False, 
                error=f'Missing required fields: {", ".join(missing_fields)}'
            ), 400

        instance_id = data['instance_id'].strip()
        access_key = data['access_key'].strip()
        secret_key = data['secret_key'].strip()
        region = data['region'].strip()

        # Validate instance ID format
        if not instance_id.startswith('i-') or len(instance_id) < 10:
            return jsonify(
                success=False, 
                error='Invalid instance ID format'
            ), 400

        # Create boto3 client with error handling
        try:
            ec2_client = boto3.client(
                'ec2',
                region_name=region,
                aws_access_key_id=access_key,
                aws_secret_access_key=secret_key
            )
        except Exception as e:
            logger.error(f"Failed to create AWS client: {str(e)}")
            return jsonify(
                success=False, 
                error='Invalid AWS credentials or region'
            ), 401

        # Describe the instance
        try:
            response = ec2_client.describe_instances(InstanceIds=[instance_id])
        except ClientError as e:
            error_code = e.response['Error']['Code']
            if error_code == 'InvalidInstanceID.NotFound':
                return jsonify(
                    success=False, 
                    error='Instance not found in this region/account'
                ), 404
            elif error_code == 'UnauthorizedOperation':
                return jsonify(
                    success=False, 
                    error='Insufficient permissions to access this instance'
                ), 403
            else:
                logger.error(f"AWS ClientError: {str(e)}")
                return jsonify(
                    success=False, 
                    error=f'AWS Error: {error_code}'
                ), 400
        except NoCredentialsError:
            return jsonify(
                success=False, 
                error='Invalid AWS credentials'
            ), 401
        except Exception as e:
            logger.error(f"Unexpected error checking instance: {str(e)}")
            return jsonify(
                success=False, 
                error='Failed to check instance'
            ), 500

        # Parse response
        reservations = response.get('Reservations', [])
        if not reservations or not reservations[0].get('Instances'):
            return jsonify(
                success=False, 
                error='Instance not found in this region/account'
            ), 404

        instance = reservations[0]['Instances'][0]
        
        # Get instance name from tags
        instance_name = instance_id  # Default to ID
        tags = instance.get('Tags', [])
        for tag in tags:
            if tag.get('Key') == 'Name' and tag.get('Value'):
                instance_name = tag['Value']
                break

        # Get instance state
        instance_state = instance.get('State', {}).get('Name', 'unknown')

        return jsonify(
            success=True,
            instance_name=instance_name,
            instance_state=instance_state,
            instance_type=instance.get('InstanceType', 'unknown')
        )

    except Exception as e:
        logger.error(f"Unexpected error in check_instance: {str(e)}")
        return jsonify(
            success=False, 
            error='Internal server error'
        ), 500

############################################################ Notifications ############################################################
def add_notification(message, category='info'):
    """Add a notification to the session."""
    try:
        if 'notifications' not in session:
            session['notifications'] = []
        
        # Limit notifications to prevent session bloat
        if len(session['notifications']) >= 10:
            session['notifications'] = session['notifications'][-9:]
        
        notification = {
            'message': str(message),
            'category': category,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        session['notifications'].append(notification)
        session.modified = True
        flash(message, category)
        
    except Exception as e:
        logger.error(f"Error adding notification: {str(e)}")
        flash("System notification error", "error")

@app.route('/clear-notifications', methods=['POST'])
def clear_notifications():
    """Clear all notifications from the session."""
    try:
        session['notifications'] = []
        session.modified = True
        return redirect(request.referrer or url_for('instances'))
    except Exception as e:
        logger.error(f"Error clearing notifications: {str(e)}")
        add_notification("Failed to clear notifications", "error")
        return redirect(url_for('instances'))

############################################################ Backup Settings ############################################################

@app.route('/backup-settings', endpoint='backup_settings')
def backup_settings():
    """Backup settings page - redirect to AWS settings for now"""
    return redirect(url_for('aws_settings'))

@app.route('/update-backup-settings', methods=['POST'])
def update_backup_settings():
    """Update backup settings."""
    try:
        config = BackupSettings.query.first()
        if not config:
            add_notification("No backup configuration found", "error")
            return redirect(url_for('backup_settings'))

        # Validate and update retention days
        try:
            retention_days = int(request.form.get('retention_days', 7))
            if retention_days < 1 or retention_days > 365:
                raise ValueError("Retention days must be between 1 and 365")
            config.retention_days = retention_days
        except (ValueError, TypeError) as e:
            add_notification(f"Invalid retention days: {str(e)}", "error")
            return redirect(url_for('backup_settings'))

        # Validate and update backup frequency
        backup_frequency = request.form.get('backup_frequency', 'daily')
        valid_frequencies = ['daily', 'weekly', 'monthly']
        if backup_frequency not in valid_frequencies:
            add_notification(f"Invalid backup frequency. Must be one of: {', '.join(valid_frequencies)}", "error")
            return redirect(url_for('backup_settings'))
        
        config.backup_frequency = backup_frequency
        config.updated_at = datetime.utcnow()
        
        db.session.commit()
        add_notification("Backup settings updated successfully", "success")
        
        # Reschedule jobs after settings change
        schedule_all_instance_backups()
        
    except Exception as e:
        logger.error(f"Error updating backup settings: {str(e)}")
        db.session.rollback()
        add_notification("Failed to update backup settings", "error")
    
    return redirect(url_for('backup_settings'))

############################################################ Main ############################################################

if __name__ == '__main__' or os.environ.get("WERKZEUG_RUN_MAIN") == "true":
    with app.app_context():
        # Create database tables
        create_tables()
        
        # Initialize scheduler
        if initialize_scheduler():
            # Schedule initial backup jobs
            schedule_all_instance_backups()
        else:
            logger.error("Failed to initialize scheduler - backup scheduling disabled")
    
    # Run the application
    app.run(
        host='0.0.0.0', 
        port=int(os.environ.get('PORT', 8080)), 
        debug=os.environ.get('DEBUG', 'False').lower() == 'true'
    )